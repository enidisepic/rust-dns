enum DnsQueryType {
    Standard, // Called QUERY by the RFC
    Inverse,  // IQUERY
    Status,   // STATUS
    Reserved, // Reserved for future use
}

enum DnsResponseCode {
    Ok,
    FormatError, // Couldn't interpret query
    // Couldn't process query due to name server problem (for example, forwarding server is down)
    ServerFailure,
    NameError, // Only meaningful if we are authoritative. Name doesn't exist.
    NotImplemented,
    Refused, // We don't want to answer your request
    Reserved,
}

pub struct DnsHeader {
    id: u16,                  // ID; generated by the client, will be the same in the reply
    is_response: bool,        // QR; 0 = query, 1 = response
    query_type: DnsQueryType, // Opcode
    is_authoritative: bool,   // AA; Only valid in response, are we authoritative
    // TC
    // Whether the response RRs are too big for the current communication channel
    // (only used in UDP). Tells the client to try again via TCP.
    is_truncated: bool,
    is_recursion_desired: bool, // RD; Whether the client wants the query to be resolved recursively
    is_recursion_available: bool, // RA; Whether the server can offer recursion
    // Z; Three bits. All zero (in RFC 1035). u8 because that's the smallest we got.
    z: u8,
    response_code: DnsResponseCode, // RCODE
    question_count: u16,            // QDCOUNT
    answer_count: u16,              // ANCOUNT
    authoritative_count: u16,       // NSCOUNT
    additional_count: u16,          // ARCOUNT
}
